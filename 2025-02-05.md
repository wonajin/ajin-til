---

# 2025-02-05

# 💬**scrum**

- 게시글 및 댓글 기능 데이터베이스에 추가
- MariaDB와의 연결 및 모델 구성

---

# 📝**Today I Learned**
## 딥다이브

### 🚀 **페이징과 메모리**

---

### 🚩**1. 문제의 시작: 메모리 관리의 어려움**

카톡, 인스타, 유튜브등 모든 앱이 실행되려면 메모리(RAM)라는 공간이 필요

앱들이 차례대로 메모리의 빈 공간에 잘 배치됨

하지만 시간이 지나 앱을 종료하고 새로운 앱을 실행하다 보면, 메모리 곳곳에 **빈 공간들이 불규칙하게 흩어지게 됨**

> 새로운 앱을 켤 메모리가 충분하지 않은 상황 발생
> 
> 
> 근데 이상하네? 빈 공간은 많은데 왜 앱이 실행이 안 되지?
> 

여기서 발생하는 문제가 바로 메모리 단편화(Fragmentation)입니다.

---

### 🚩 **2. 메모리 단편화란?**

### ✅ **외부 단편화 (External Fragmentation)**

- 메모리 여기저기에 빈 공간이 **흩어져 있어서** 새로운 앱이 실행되지 못하는 상황
- 마치 가방에 빈틈은 많은데, 필요한 책 한 권을 넣을 수 없는 것과 같음
- **문제점:** 메모리가 남아있어도 쓸 수 없는 상태 → 비효율적 메모리 사용

### ✅ **내부 단편화 (Internal Fragmentation)**

- 메모리 블록을 할당받았는데, **사용하지 않고 남는 공간**이 생기는 상황
- 마치 피자 한 판을 시켰는데, 끝부분을 항상 남기는 것처럼 낭비되는 부분
- **문제점:** 공간은 할당되었지만 실제로는 사용되지 않아 낭비 발생

---

### ⚡ **3. 이 문제를 해결하기 위한 등장: 페이징 기법**

운영체제는 이 단편화 문제를 해결하기 위해 새로운 방법을 생각했습니다.

> "메모리를 잘게 나눠서 필요한 만큼만 사용하는 방법"
> 
> 
> 이 아이디어로 등장한 것이 바로 **페이징(Paging)** 기법입니다.
> 

### 📦 **페이징 기법의 핵심 아이디어**

- 메모리를 **작은 고정 크기 블록**으로 쪼갬
    - 논리적 메모리 → **페이지(Page)**
    - 물리적 메모리 → **프레임(Frame)**
- 앱을 실행할 때 필요한 페이지를 아무 프레임에나 배치 가능
- **연속된 공간이 필요 없음** → 외부 단편화 문제 해결!

> 비유:
> 
> 
> 커다란 가방에 무조건 큰 책을 넣는 대신, **작은 상자들에 나눠 담는 방식**
> 
> 빈 상자만 있으면 그곳에 책 조각(페이지)을 배치할 수 있음
> 

---

### 🎯 **4. 페이징 기법으로 얻은 이점**

1. ✅ **외부 단편화 해결**
    - 페이지를 아무 프레임에나 배치할 수 있어 빈 공간을 효율적으로 활용
    - 메모리 낭비를 최소화하고, 더 많은 앱을 동시에 실행 가능
2. ✅ **가상 메모리(Virtual Memory) 지원**
    - 실제 메모리보다 더 큰 메모리 공간을 사용할 수 있는 환경 제공
    - 필요한 페이지만 메모리에 불러오고 나머지는 디스크에 두는 방식 → **효율적 메모리 사용**
3. ✅ **프로세스 실행 속도 개선**
    - *지연 페이지 적재(Demand Paging)**로 필요한 부분만 메모리에 로드
    - 초기 로딩 속도 향상, 메모리 사용량 절약

---

### ⚠️ **5. 그런데… 페이징도 완벽하지 않다! (내부 단편화 등장)**

페이징은 외부 단편화 문제를 해결했지만, 새로운 문제가 생겼습니다.

- 페이지 크기가 **고정되어** 있기 때문에, 프로세스의 마지막 페이지가 완전히 채워지지 않는 경우 **빈 공간**이 발생
- 이 빈 공간이 바로 **내부 단편화(Internal Fragmentation)**입니다.

> 비유:
> 
> 
> 피자 상자가 항상 같은 크기인데, 작은 조각만 필요한 상황
> 
> 남은 공간이 있지만 그대로 버려지는 셈
> 

---

### 🛠️ **6. 운영체제의 대응 전략 (단편화 완화 방법)**

### ✅ **내부 단편화 줄이기**

1. **페이지 크기 최적화:**
    - 너무 크면 낭비가 심하고, 너무 작으면 관리 비용 증가
2. **슬랩 할당자(Slab Allocator):**
    - 비슷한 크기의 데이터를 효율적으로 관리해 낭비 줄이기

### ✅ **외부 단편화 방지**

1. **페이징 사용:**
    - 이미 외부 단편화 문제를 해결하는 방법
2. **세그멘테이션+페이징 혼합:**
    - 두 기법의 장점을 결합해 더욱 효율적인 메모리 관리
3. **메모리 압축(Compaction):**
    - 흩어진 빈 공간을 한쪽으로 모아 연속된 공간 확보 (다만 성능 오버헤드 큼)

---

### 🗒️ **7. 페이징과 단편화의 흐름 정리**

1. **문제 인식:**
    - 메모리 공간의 비효율적인 사용 → 외부 단편화, 내부 단편화 발생
2. **해결책 등장:**
    - **페이징 기법**으로 외부 단편화 해결
    - 가상 메모리 지원으로 더 효율적인 메모리 활용
3. **새로운 도전:**
    - 내부 단편화 문제 발생
    - 페이지 크기 조절, 슬랩 할당자 같은 기법으로 내부 단편화 최소화
4. **최종 목표:**
    - **효율적인 메모리 사용**
    - **더 많은 프로세스를 동시에 실행**
    - **빠르고 안정적인 시스템 성능 유지**

---

### ✅ **8. 결론: 왜 이게 중요한가?**

- **운영체제의 핵심:** 메모리 관리의 효율성이 곧 시스템 성능으로 직결
- **현대 시스템:** 스마트폰, 서버, 클라우드 등 모든 환경에서 메모리 효율은 중요
- **결론:**
    - 더 빠르고 효율적인 시스템
    - 더 많은 작업 처리 가능
    - 리소스 낭비 최소화

## 게시글과 댓글 기능 데이터베이스로 구현하기

### **1. 데이터베이스 설계**

- **게시글 테이블 (posts)**
    - id (PK), title, content, user_id (FK), created_at, updated_at
- **댓글 테이블 (comments)**
    - id (PK), post_id (FK), content, user_id (FK), created_at

### **2. 모델 구성 (boardModel.js)**

- 기존 JSON 모델 제거 (jsonPostModel.js → 삭제)
- MariaDB와 연결된 boardModel.js를 통해 게시글과 댓글 데이터를 관리

```
// boardModel.js
import db from '../config/db.js';

export const createPost = async (title, content, userId) => {
  const [result] = await db.execute(
    'INSERT INTO posts (title, content, user_id, created_at) VALUES (?, ?, ?, NOW())',
    [title, content, userId]
  );
  return result;
};

export const createComment = async (postId, content, userId) => {
  const [result] = await db.execute(
    'INSERT INTO comments (post_id, content, user_id, created_at) VALUES (?, ?, ?, NOW())',
    [postId, content, userId]
  );
  return result;
};
```

### **3. 서버 구조 변경**

- 프론트엔드 서버: `app.js`
- 백엔드 서버: `server.js`
- 게시글 및 댓글 관련 API 라우터 추가

```
// server.js
import express from 'express';
import postRouter from './routes/postRouter.js';

const app = express();
app.use(express.json());

app.use('/posts', postRouter);

app.listen(3000, () => console.log('Server running on port 3000'));
```

### **4. 라우터 및 컨트롤러 구성**

- `postRouter.js`에서 게시글 및 댓글 라우트 관리
- 게시글 작성, 조회, 댓글 작성 기능 구현

```
// postRouter.js
import { Router } from 'express';
import { createPost, createComment } from '../controllers/postController.js';

const router = Router();

router.post('/', createPost);
router.post('/:postId/comments', createComment);

export default router;
```

### **5. 프론트엔드 수정**

- 게시글 작성 및 댓글 등록 기능을 Fetch API로 서버와 연동
- 프론트엔드에서 서버 요청을 통해 데이터 저장 및 불러오기 구현

---

# 📚**Today's Challenge**

- 데이터베이스 연결 과정에서 외래 키 설정과 테이블 관계에 대한 이해 필요
- 게시글과 댓글 간의 관계를 명확하게 관리하기 위해 JOIN 쿼리 학습 예정

---

# 🌟**Review**

- 데이터베이스를 활용한 게시글과 댓글 관리 기능 구현을 완료
- 기존 JSON 모델에서 DB 모델로 전환하면서 코드 구조가 더 체계적으로 개선됨
- 과제를 얼른 끝내고 싶은데 쉽지않다 그래도 힘내야지
