## 인증, 인가

**-인증**

: 접근 가능한 유효한 유저임을 증명하는 것 (ex 기차표를 확인해야 기차 탈 수 있는것)

**-인가**

:인증되어 서버에 가능한 사용자라고 하더라도 권한에 따라 접근 할 수 있는 리소스가 다르면 

그 권한에 따라 인가 하는 것

(ex 기차표 좌석 지정, 좌석 등급에 따라 다른 서비스) 

여기서 티켓이 쿠키, 세션 , JWT

여기서 기차는 클라이언트와 서버가 데이터를 주고 받기 위해 사용되는 HTTP 프로토콜

티켓이 필요한 이유=HTTP의 특징

1. Connectionless
⇒ 연결이 바로 끊어지면 로그인해도 다음 페이지로 넘어가면 로그아웃

1. Statelse
⇒ 서버는 클라이언트의 상태 정보를 저장 하지 않기 때문에 똑같은 사용자와 통신을
하더라도 이전에 기록을 전혀 알지 못함
상품을 선택해도 장바구니에서 알 수X

---

## 쿠키-세션

1. **쿠키**
인증 유효 시간을 설정할 수 있고 유효 시간이 정해진다면 클라이언트가 종료되어도 쿠키가 유지된다.
서버와 요청 응답으로 인해 `쿠키`가 저장되면 다음 요청은 `쿠키`에 담긴 정보를 이용해 참조한다.

- **동작 방식**:
    1. 사용자가 로그인하면 서버에서 인증 정보를 포함한 쿠키를 생성하고 클라이언트에 전달
    2. 클라이언트는 쿠키를 저장하고, 이후 요청할 때마다 쿠키를 서버로 보냄
    3. 서버는 쿠키에 담긴 정보를 이용해 사용자를 인증
    
- **장점:**
    - 자동 로그인 및 세션 유지 가능: 유효 기간을 설정해 브라우저가 닫혀도 세션을 유지할 수 있음.
    - 클라이언트에 저장되어 서버 자원 절약: 사용자 정보가 클라이언트에 저장되므로 서버 자원을 차지하지 않음.
    - 간단한 구현: 설정과 사용이 간단해 쉽게 활용 가능

- **단점**:
    - 보안 취약성: 클라이언트에 저장되기 때문에 탈취당할 위험이 있음. (예: XSS, 스니핑 공격)
    - 크기 제한: 쿠키에 저장 가능한 데이터는 4KB로 제한되어 있음.
    - 데이터 변조 위험: 클라이언트에서 데이터를 수정할 수 있어, 민감한 정보 저장에 적합하지 않음

- **주요 사용 예시**:
    - 보안이 중요한 정보보다는 장바구니, 자동 로그인 설정에 사용

---

**2.세션**
 

**동작 방식**

1. 클라이언트가 로그인 요청
2. 서버에서 고유한 세션ID를 부여하고 저장소에 저장 후 클라이언트로 발급
3. 클라이언트는 발급받은 세션ID를 쿠키에 저장 후 요청 시마다 서버에 전송
4. 서버는 세션ID와 저장된 정보를 대조해 데이터 제공

**장점**

- 서버에 저장되어 보안성 높음: 세션 ID만 클라이언트에 전달하고 실제 데이터는 서버에서 관리하므로 상대적으로 안전함.

⇒ 쿠키는 매번 아이디 패스워드등 민감정보를 재전송해야 했다

- 유저별 상태 유지: 서버가 유저의 상태를 유지하여 다양한 서비스를 안정적으로 제공할 수 있음.

- 상세한 접근 제어 가능: 서버에서 관리하므로 데이터 접근 및 제어가 수월함.

**단점**

- 서버 부하 증가: 세션을 서버가 관리하므로, 사용자 수가 많을 경우 서버에 부담이 커질 수 있음.
- 유지 비용: 서버에 데이터를 저장하므로 유지 보수 및 확장 비용이 발생.
- 세션 하이재킹 위험: 세션 ID가 탈취될 경우 세션 하이재킹 공격에 노출될 수 있음

세션 하이재킹

:세션 하이재킹은 사용자의 세션 아이디를를 탈취하여 서버와의 인증된 세션을 가로채는 방식

---

## JWT

**1. 토큰(JWT)**

- 세션 방식과 유사하게 토큰 자체를 쿠키나 HTTP 헤더에 담아 전송 가능
- 토큰은 Header, Payload, Verify Signature 세 부분으로 구성됨
    - Header: 암호화 알고리즘 옵션
    - Payload: 유저 ID 등 인증 정보
    - Verify Signature: Secret Key로 암호화되어 보안성 제공
    

**토큰 동작 방식**

1. 클라이언트가 로그인 요청
2. 서버는 유저의 고유 ID와 인증 정보를 Payload에 담아 JWT 생성
→ 유저 세션 유지할 필요 없음
3. 유효 기간 설정 후 Secret Key로 토큰 발급
4. 발급된 토큰은 쿠키 또는 로컬스토리지에 저장하여 요청 시마다 함께 전송
5. 서버는 Secret Key로 토큰 검증
6. 검증 완료 후 대응 데이터 전송

-시크릿키: JWT의 서명(Signature=Header+Payload)을 생성하고 검증하는 데 사용되는 서버만 아는 비밀 키로, 토큰의 무결성을 보장하는 역할

- **장점**
    - 분산 시스템에서 사용하기 용이: 서버에 세션 데이터를 저장하지 않으므로, 여러 서버에서 쉽게 확장 가능.
    - 독립적인 인증 정보: 토큰 자체에 필요한 정보를 담고 있어 서버가 유저의 상태를 기억할 필요가 없음.
    - 빠른 인증 처리: 토큰을 사용해 검증하므로 데이터베이스 접근 없이 빠르게 처리 가능.
- **단점**
    - 유효 기간 만료 전까지 취소 불가: 한 번 발급된 JWT는 서버에서 관리할 수 없기 때문에, 탈취 시 유효 기간 동안 악용될 수 있음.
    - 토큰 크기: 일반적으로 세션보다 크기 때문에, 토큰이 커질수록 네트워크 성능에 영향 가능.
    - 보안 취약성: 토큰이 탈취되면 유효 기간 내 언제든 사용할 수 있으므로 추가적인 보안 조치 필요 ,Refresh Token 사용으로 피해 최소화 가능.
    

⇒세션 같은 경우에는 악의적으로 사용된다면 해당 세션을 삭제하면 된다

 -Refresh Token: Access Token의 유효기간이 만료되었을 때 새 Access Token을 발급받기 위해 사용하는 토큰

| 요소 | Access Token | Refresh Token |
| --- | --- | --- |
| **역할** | 자원 접근을 허용 | 새 Access Token을 발급받기 위한 용도 |
| **유효기간** | 짧음 (예: 5분~30분) | 비교적 김 (예: 며칠~몇 주) |
| **저장 위치** | 클라이언트 (주로 쿠키나 로컬 스토리지) | 클라이언트 (보안 강화 필요) |
| **갱신 방식** | 만료 시 Refresh Token을 통해 갱신 | 보통 만료 전 수동으로 갱신하거나 새 로그인 |
|  |  |  |

### 

---

### 세션 인증과 JWT 인증 비교 요약

| 특징 | 세션 인증 | JWT 인증 |
| --- | --- | --- |
| **저장 위치** | 서버에 저장 | 클라이언트에 저장 |
| **확장성** | 낮음 | 높음 |
| **로그아웃 제어** | 서버에서 직접 제어 가능 | 클라이언트에서 직접 만료 처리 필요 |
| **보안성** | 비교적 안전 | 탈취 시 보안에 취약할 수 있음 |

## 무엇을 선택할까?

- 대규모 웹 애플리케이션이나 분산 시스템에서는 **JWT**를 선호하는 경우가 많음. 이유는 다음과 같음:
    - 서버 간 인증을 공유하기 쉽고, 세션 저장소를 관리할 필요가 없기 때문
    - 마이크로서비스나 모바일, 웹 등 다양한 클라이언트를 통합적으로 지원하는 데 유리함
    
- 반면, 일반적인 웹 애플리케이션이나 보안이 중요한 서비스에서는 **쿠키-세션**을 사용하는 경우가 많음. 이유는 다음과 같음:
    - 세션 데이터가 서버에 안전하게 저장되고, 인증 정보를 쉽게 무효화할 수 있기 때문
    - 탈취되더라도 서버에서 해당 세션을 종료할 수 있어 보안에 상대적으로 안전함

⇒ 아무래도 요즘 시대엔 사용자증가와 많은 데이터 사용으로 인해 JWT가 선호되지 않나 싶음

JWT는 상태를 서버에 저장하지 않고 클라이언트에 저장되므로, 세션 정보 공유 문제를 피할 수 있음. 

이로 인해 여러 서버가 독립적으로 동작하면서도 인증 상태를 유지 (=무상태 인증) 그래서 무중단 서비스가 세션보다 더 쉽게 가능함
