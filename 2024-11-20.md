---

# 2024-11-20

# 💬**scrum**

- 딥다이브

---

# 📝**Today I Learned**

# 목차

- 딥다이븨 주제 선정
1. 서브쿼리에 대한 정의와 장단점에 대해 발표해주세요.
2. RDBMS의 한계와 NoSQL을 사용하는 이유에 대해 발표해주세요.
3. 트랜잭션의 특성(ACID)에 대해 발표해주세요.
4. EXPLAIN, ANALYZE 쿼리에 대해 발표해주세요.
5. mariadb(mysql)에서의 스캔(SCAN) 종류와 이를 활용한 분석방법에 대해서 발표해주세요.

——— 이하 난이도 어려운 주제. ———

1. 쿼리 옵티마이저에 대해 발표해주세요.
2. CAP 이론에 대해서 발표해주세요.
→ (Partition Tolerance 를 중심으로)
3. binlog 에 대해서 설명하고 이를 통해 데이터를 복원하는 시연을 포함하여 발표해주세요.

### 1. 서브쿼리의 정의와 장단점

- **정의**: 서브쿼리는 하나의 SQL 쿼리 안에 중첩된 또 다른 쿼리입니다. 주로 데이터를 필터링하거나, 특정 조건을 만족하는 결과를 반환하기 위해 사용됩니다.
- **장점**:
    - 복잡한 조건을 단순화할 수 있습니다.
    - 단계적으로 데이터를 처리하여 가독성을 높입니다.
- **단점**:
    - 성능 저하 가능성 (특히 중첩 쿼리가 많을 경우).
    - 대규모 데이터셋에서는 비효율적일 수 있습니다.

**한줄요약**: 서브쿼리는 중첩된 쿼리로 가독성을 높이지만, 성능에 영향을 줄 수 있습니다.

---

### 2. RDBMS의 한계와 NoSQL을 사용하는 이유

- **RDBMS 한계**:
    - 스키마가 고정적이라 데이터 구조 변화에 유연하지 못함.
    - 대규모 트래픽 처리나 수평 확장(Scale-out)이 어려움.
- **NoSQL 사용 이유**:
    - 비정형 데이터 처리에 유리함.
    - 유연한 스키마, 빠른 읽기/쓰기 성능 제공.
    - 수평 확장이 용이.

**한줄요약**: RDBMS는 구조적 한계가 있지만, NoSQL은 유연성과 확장성을 제공합니다.

---

### 3. 트랜잭션의 특성 (ACID)

- **Atomicity (원자성)**: 트랜잭션은 전부 실행되거나 전혀 실행되지 않아야 함.
- **Consistency (일관성)**: 데이터베이스는 항상 유효한 상태를 유지해야 함.
- **Isolation (고립성)**: 동시에 실행되는 트랜잭션은 서로 영향을 미치지 않음.
- **Durability (지속성)**: 트랜잭션 완료 후에는 데이터가 영구적으로 저장됨.

**한줄요약**: ACID는 트랜잭션의 안전성과 일관성을 보장합니다.

---

### 4. EXPLAIN, ANALYZE 쿼리

- **EXPLAIN**: 쿼리 실행 계획을 분석하여 실행 순서, 사용 인덱스 등을 파악하는 명령어.
- **ANALYZE**: 실행 계획과 실제 실행 결과를 비교하여 성능을 측정.

**한줄요약**: EXPLAIN은 실행 계획을, ANALYZE는 실제 실행 결과를 확인합니다.

---

### 5. MariaDB(MySQL)에서의 스캔 종류와 분석 방법

- **스캔 종류**:
    - **Full Table Scan**: 테이블의 모든 행을 읽음.
    - **Index Scan**: 인덱스를 기반으로 필요한 행만 읽음.
    - **Range Scan**: 특정 조건에 맞는 범위만 스캔.
- **분석 방법**:
    - 실행 계획(EXPLAIN)으로 스캔 유형 확인.
    - 인덱스를 적절히 설계하여 Full Table Scan 최소화.

**한줄요약**: MariaDB 스캔은 실행 계획을 통해 확인하며, 인덱스를 활용해 최적화할 수 있습니다.

---

### 6. 쿼리 옵티마이저

- **정의**: 쿼리 옵티마이저는 SQL 쿼리의 실행 계획을 최적화하는 엔진으로, 가장 효율적인 실행 경로를 선택합니다.
- **기능**:
    - 인덱스 사용 여부 판단.
    - 조인 순서 최적화.
    - 비용 기반 평가를 통해 최적의 경로 결정.

**한줄요약**: 쿼리 옵티마이저는 SQL 쿼리의 실행 계획을 자동으로 최적화합니다.

---

### 7. CAP 이론 (Partition Tolerance 중심)

- **CAP 이론**:
    - **Consistency**: 모든 노드에서 동일한 데이터를 보장.
    - **Availability**: 모든 요청에 대해 응답을 보장.
    - **Partition Tolerance**: 네트워크 분할 시에도 시스템이 동작.
- **Partition Tolerance의 중요성**: 분산 시스템에서 네트워크 장애가 발생해도 데이터 무결성과 가용성을 유지해야 함.

**한줄요약**: CAP 이론은 분산 시스템에서 Consistency, Availability, Partition Tolerance 간의 균형을 강조합니다.

---

### 8. binlog와 데이터 복원

- **binlog 정의**: MySQL의 바이너리 로그로, 데이터 변경 내역과 트랜잭션 기록을 저장.
- **복원 과정**:
    - binlog에서 변경 내역 추출.
    - `mysqlbinlog` 명령어를 통해 데이터를 복원.

**한줄요약**: binlog는 데이터 변경 기록을 저장하며 복원에 유용합니다

---

# 📚**Today's Challenge**

- EXPLAIN, ANALYZE 쿼리 딥다이브

---

# **📖 Introduction**

### 실행 계획이란?

동일한 쿼리여도 현재 DBMS의 상황에 따라서 가장 효율적으로 쿼리를 실행할 수 있는 방법은 다양하다

DBMS에서는 옵티마이저가 통계 정보를 참고하여 다양한 방법 중 가장 효율적인 방법을 찾아서 쿼리를 실행하는데, 이렇게 쿼리를 실행하는 방법을 실행 계획이라고 한다

⇒MySQL의 실행 계획은 `EXPLAIN`명령으로 확인할 수 있다

`ANALYZE` 문을 함께 붙이면 쿼리의 실행시간을 포함한 구체적인 계획을 분석하여 성능을 분석 할 수 있다

---

# **📝EXPLAIN 쿼리**

### ✔️ EXPLAIN

: SQL 쿼리를 실행하기 전에 실행 계획을 분석하여 데이터베이스가 해당 쿼리를 어떻게 처리할지를 보여줍니다

⇒

- 성능 최적화에 중요한 정보
- 쿼리가 직접적으로 실행 되는 것은 아님

---

### 사용 예시

```sql
EXPLAIN SELECT * FROM users WHERE age > 30 AND city = 'Seoul';
```

### **출력 예시**

| id | select_type | table | type | possible_keys | key | rows | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | users | ref | idx_age,idx_city | idx_city | 10 | Using where |
1. **id**
    - 쿼리 실행 순서
    - 숫자가 클수록 먼저 실행
2. **select_type**
    - 쿼리의 유형
    `SIMPLE`(단순 SELECT), `PRIMARY`(메인 쿼리), `SUBQUERY`(서브쿼리), `DERIVED`(파생 테이블).
3. **table**
    - 작업 중인 테이블 이름
4. **type**
    - 조인 방식
        - `ALL` (Full Table Scan): 테이블 전체를 검색, 느림
        - `index` (Index Scan): 인덱스만 검색
        - `range`: 특정 범위 내의 값만 검색
        - `ref`: 인덱스의 키 값으로 행을 검색
        - `const`/`eq_ref`: 한 행만 검색, 빠름
5. **possible_keys**
    - 사용할 수 있는 인덱스 목록
6. **key**
    - 실제 사용된 인덱스
7. **rows**
    - 조회된 예상 행 수
8. **Extra**
- `Using where`: WHERE 조건을 사용
- `Using index`: 인덱스를 통해 데이터를 직접 검색
- `Using filesort`: 추가 정렬 작업 필요 (성능 저하)
- `Using temporary`: 임시 테이블 사용

---

### ✔️**결과 해석과 관련된 용도**

예를 들어:

1. **type이 ALL**일 경우:
    - Full Table Scan을 의미하므로 인덱스를 추가하거나 쿼리를 재작성해야 할 수 있습니다
2. **key가 NULL**일 경우:
    - 적절한 인덱스가 없는 상태이므로, 해당 조건을 처리할 인덱스를 설계해야 합니다
3. **Extra에 Using temporary** 또는 **Using filesort**가 있을 경우:
    - 임시 테이블이나 정렬 작업으로 성능이 저하될 수 있으므로, 이를 없앨 방법을 고려합니다

 

---

## EXPLAIN 의 함정

EXPLAIN은 실제 실행 결과를 다루지 않고, 실행 전 예측에 기반

그렇기에 항상 최적의 실행계획을 **보장하지는 않고,** 
때로는 **실제 실행 전략이 크게 다를 수도 있습니다.**

특히 DB 옵티마이저에게 제공되는 통계 정보(데이터의 분포도와 인덱스 정보 등)가 부정확한 경우 잘못된 실행계획을 세울 가능성이 높습니다.

## EXPLAIN ANALYZE 란?

MySQL이 제공하는 쿼리 프로파일링 도구입니다. (MySQL 8.0.18 부터 지원합니다.)

쿼리 실행 중 MySQL이 어디서 시간을 많이 썼는지, 그 이유가 뭔지 분석할 수 있습니다.

쿼리를 실제 실행하며 그 중 얻는 모든 시간과 행수를 측정합니다.

결과적으로 실행 전 계획과, 실제 측정치를 같이 출력합니다.

> EXPLAIN과의 차이점
> 
> - `EXPLAIN` -> 쿼리를 실행하지 않고, 실행 과정을 예측
> - `EXPLAIN ANALYZE` -> 쿼리를 실행하고, 실행 과정을 분석

---

# **📝ANALYZE 쿼리**

### ✔️ **ANALYZE**

 쿼리를 실제로 실행하고, 실행 계획과 실행 결과를 비교해 성능 통계를 제공합니다

- PostgreSQL 및 최신 MySQL에서 사용 가능하며, MariaDB는 비슷한 기능을 제공합니다.
- `EXPLAIN ANALYZE`로 함께 사용

→ANALYZE는 데이터베이스 종류에 따라 단독으로 사용할 수 있는 경우도 있고
반드시 EXPLAIN과 함께 사용하는 경우도 있음

### 

### **PostgreSQL**: `ANALYZE`는 통계 갱신 용도로 단독 사용 가능. 실행 계획 확인 시 `EXPLAIN ANALYZE` 사용.

- **MySQL/MariaDB**: `ANALYZE`는 단독 실행 불가. 실행 계획 확인은 `EXPLAIN ANALYZE`로만 가능.
- **SQLite**: `ANALYZE`는 통계 최적화에 사용되며, 실행 계획은 `EXPLAIN QUERY PLAN`으로 확인

---

### **ANALYZE 주요 기능**

1. **실제 실행 시간**
    - 각 작업이 실제로 소요된 시간과 예측된 시간 비교.
2. **실제 처리된 행 수**
    - 실제 스캔된 행과 예상 행 비교.

### 

### **사용 예시**

```sql

EXPLAIN ANALYZE SELECT * FROM users WHERE age > 30 AND city = 'Seoul';

```

### **출력 예시**

```
-> Filter: (age > 30 and city = 'Seoul')  (cost=0.30 rows=100)
    -> Table scan on users  (cost=0.20 rows=1000)

```

- **Filter**: 필터 조건 설명
    - `age > 30 and city = 'Seoul'`
    - 조건을 통해 데이터가 추가로 걸러짐
- **cost**: 예상 실행 비용 (CPU 사이클, I/O 접근 빈도 등 리소스 소모에 대한 추정치)
- **rows**: 예상 처리 행 수
- **loop**: 작업을 반복한 횟수
- **actual:** 실행결과

### **표 형식이 아닌 이유**

- `ANALYZE`의 출력은 주로 성능 데이터를 요약하여 제공하기 때문에, 표 형식보다 **계층적 구조나 텍스트 기반** 형식으로 출력됩니다.

## EXPLAIN은 이제 필요없나?

 `EXPLAIN ANALYZE` 이 실제 결과를 보여주면 `EXPLAIN`은 필요 없지 않을까? 라는 의문

⇒

그러나 `EXPLAIN ANALYZE`는 실행 결과가 나와야 하기 때문에

**매우 느린 쿼리거나, 상용 환경에서 부하가 큰 쿼리를 분석하려 할 경우 부담이 될 수 있음**

이런 경우 실행을 하지 않아도 전략을 예측할 수 있는 `EXPLAIN` 이 더 유용할 수 있다

---

# 최종 간단 정리

- EXPLAIN은 실행 계획을, ANALYZE는 실제 실행 결과를 확인

### **EXPLAIN과 ANALYZE의 차이**

| **특징** | **EXPLAIN** | **ANALYZE** |
| --- | --- | --- |
| 실행 여부 | 실행하지 않음 | 쿼리를 실제로 실행함 |
| 제공 정보 | 예상 실행 계획 | 실제 실행 시간 및 결과 통계 |
| 안전성 | 데이터 변경 없음 | 데이터 변경 가능 (특히 DML 쿼리 시 주의 필요) |

이부분 무슨뜻?

⇒`ANALYZE` 명령어가 실제 데이터를 읽고, 통계 정보를 갱신하거나 업데이트 과정에서 데이터를 변경할 수도 있기 때문
**INSERT, UPDATE, DELETE와 같은 DML 쿼리를 `EXPLAIN ANALYZE`로 실행**하면, 쿼리가 실제로 수행되어 데이터가 변경될 수 있다

- **PostgreSQL**
    - `EXPLAIN`은 실행 계획만 보여줌(데이터 변경 없음).
        - 예: `EXPLAIN DELETE ...` → 데이터 삭제되지 않음.
    - `EXPLAIN ANALYZE`는 쿼리를 실행하므로 DML 작업이 실제로 수행됨.
- **MySQL/MariaDB**
    - MySQL에서는 `EXPLAIN`은 읽기 전용으로 실행 계획만 보여줌.
    - `EXPLAIN ANALYZE`는 실제 실행 결과를 포함하지만, DML 쿼리에서 데이터 변경은 발생하지 않습니다.

결론은 우리가 쓰는 **MySQL/MariaDB환경에선 큰 차이 없다!**

---

# 💫review

 

- 딥다이브를 항상 하면서 느끼는거지만
이미 알고 있는 부분과 관련된 부분이 많고,
내가 알고 있는 지식의 깊이가 얕다는것이다
많은 사람들과 이렇게 여러 주제에 대해 알아갈수있는 과정이 소중하다.
